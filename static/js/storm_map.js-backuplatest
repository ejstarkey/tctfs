// Storm Map - COMPLETE with category-colored tracks and proper tc-eye logic
let map, stormData, eyeMarker = null, currentBasin = null;

const BASIN_SCALES = {
    'SH': {
        name: 'Australian Tropical Cyclone Scale',
        thresholds: [34, 48, 64, 87, 108],
        categories: [
            { name: 'Tropical Low', range: '< 63 km/h', color: '#5ebaff' },
            { name: 'Category 1', range: '63-88 km/h', color: '#00faf4' },
            { name: 'Category 2', range: '89-117 km/h', color: '#ffffcc' },
            { name: 'Category 3', range: '118-159 km/h', color: '#ffe775' },
            { name: 'Category 4', range: '160-199 km/h', color: '#ffc140' },
            { name: 'Category 5', range: '≥ 200 km/h', color: '#ff8f20' }
        ],
        textColors: ['#000', '#000', '#000', '#ff8c00', '#ff6600', '#ff0000']
    },
    'IO': {
        name: 'Australian Tropical Cyclone Scale',
        thresholds: [34, 48, 64, 87, 108],
        categories: [
            { name: 'Tropical Low', range: '< 63 km/h', color: '#5ebaff' },
            { name: 'Category 1', range: '63-88 km/h', color: '#00faf4' },
            { name: 'Category 2', range: '89-117 km/h', color: '#ffffcc' },
            { name: 'Category 3', range: '118-159 km/h', color: '#ffe775' },
            { name: 'Category 4', range: '160-199 km/h', color: '#ffc140' },
            { name: 'Category 5', range: '≥ 200 km/h', color: '#ff8f20' }
        ],
        textColors: ['#000', '#000', '#000', '#ff8c00', '#ff6600', '#ff0000']
    },
    'AL': {
        name: 'Saffir-Simpson Hurricane Scale',
        thresholds: [34, 64, 83, 96, 113, 137],
        categories: [
            { name: 'TD/TS', range: '< 64 kt', color: '#5ebaff' },
            { name: 'Category 1', range: '64-82 kt', color: '#00faf4' },
            { name: 'Category 2', range: '83-95 kt', color: '#ffffcc' },
            { name: 'Category 3', range: '96-112 kt', color: '#ffe775' },
            { name: 'Category 4', range: '113-136 kt', color: '#ffc140' },
            { name: 'Category 5', range: '≥ 137 kt', color: '#ff8f20' }
        ],
        textColors: ['#000', '#000', '#000', '#ff8c00', '#ff6600', '#ff0000']
    }
};

BASIN_SCALES.EP = BASIN_SCALES.AL;
BASIN_SCALES.CP = BASIN_SCALES.AL;
BASIN_SCALES.WP = BASIN_SCALES.AL;

function initStormMap(stormId) {
    const mapContainer = document.querySelector('[data-storm-id]');
    currentBasin = mapContainer?.dataset.basin || 'WP';
    
    map = new maplibregl.Map({
        container: 'storm-map',
        style: 'https://basemaps.cartocdn.com/gl/positron-gl-style/style.json',
        center: [140, 20],
        zoom: 4
    });

    map.addControl(new maplibregl.NavigationControl(), 'top-right');
    map.addControl(new maplibregl.ScaleControl({ unit: 'nautical' }), 'bottom-left');
    map.addControl(new maplibregl.FullscreenControl(), 'top-right');

    map.on('load', () => {
        addLegend();
        loadStormData(stormId);
    });
}

function addLegend() {
    const scale = BASIN_SCALES[currentBasin];
    const legendDiv = document.createElement('div');
    legendDiv.style.cssText = 'position: absolute; top: 20px; left: 20px; background: white; padding: 1rem; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.15); z-index: 1000; font-family: system-ui; max-width: 280px;';
    
    let html = `<div style="font-weight: bold; margin-bottom: 0.75rem; font-size: 0.9rem;">${scale.name.toUpperCase()}</div>`;
    scale.categories.forEach(cat => {
        html += `<div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem;"><div style="width: 20px; height: 20px; background: ${cat.color}; border-radius: 50%; border: 2px solid white;"></div><span style="font-size: 0.85rem;">${cat.name} ${cat.range}</span></div>`;
    });
    html += `<div style="border-top: 1px solid #e5e7eb; padding-top: 0.75rem; margin-top: 0.75rem;"><div style="font-weight: 600; margin-bottom: 0.5rem; font-size: 0.85rem;">TRACK</div><div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.25rem;"><div style="width: 30px; height: 3px; background: linear-gradient(90deg, #5ebaff, #ff8f20);"></div><span style="font-size: 0.8rem;">Observed Track (Category Colored)</span></div><div style="display: flex; align-items: center; gap: 0.5rem;"><div style="width: 30px; height: 3px; background: #3b82f6; opacity: 0.5;"></div><span style="font-size: 0.8rem;">Forecast Track (50% opacity)</span></div></div>`;
    legendDiv.innerHTML = html;
    map.getContainer().appendChild(legendDiv);
}

async function loadStormData(stormId) {
    try {
        const response = await fetch(`/api/storms/${stormId}/track`);
        const data = await response.json();
        if (!data.track || data.track.length === 0) return;
        stormData = data;
        
        const latest = data.track[data.track.length - 1];
        document.getElementById('current-vmax').textContent = `${latest.vmax_kt || '--'} kt`;
        document.getElementById('current-mslp').textContent = `${latest.mslp_hpa || '--'} mb`;
        document.getElementById('current-position').textContent = `${latest.latitude.toFixed(2)}°, ${latest.longitude.toFixed(2)}°`;
        document.getElementById('current-category').textContent = getCategoryName(latest.vmax_kt);
        
        plotTrack(data.track);
        fitMapToTrack(data.track);
    } catch (error) {
        console.error('Error:', error);
    }
}

function getCategory(vmax) {
    const scale = BASIN_SCALES[currentBasin];
    const thresholds = scale.thresholds;
    if (vmax < thresholds[0]) return 0;
    if (vmax < thresholds[1]) return 1;
    if (vmax < thresholds[2]) return 2;
    if (vmax < thresholds[3]) return 3;
    if (vmax < thresholds[4]) return 4;
    return 5;
}

function getCategoryText(vmax) {
    const cat = getCategory(vmax);
    return cat === 0 ? 'LOW' : cat.toString();
}

function getCategoryName(vmax) {
    const cat = getCategory(vmax);
    return BASIN_SCALES[currentBasin].categories[cat].name;
}

function getCategoryColor(cat) {
    return BASIN_SCALES[currentBasin].categories[cat].color;
}

function catmullRomSpline(points, numSegments = 15) {
    if (points.length < 3) return points;
    const smoothed = [points[0]];
    for (let i = 0; i < points.length - 1; i++) {
        const p0 = points[Math.max(0, i - 1)];
        const p1 = points[i];
        const p2 = points[i + 1];
        const p3 = points[Math.min(points.length - 1, i + 2)];
        for (let t = 0; t < numSegments; t++) {
            const t1 = t / numSegments, t2 = t1 * t1, t3 = t2 * t1;
            smoothed.push([
                0.5 * ((2 * p1[0]) + (-p0[0] + p2[0]) * t1 + (2 * p0[0] - 5 * p1[0] + 4 * p2[0] - p3[0]) * t2 + (-p0[0] + 3 * p1[0] - 3 * p2[0] + p3[0]) * t3),
                0.5 * ((2 * p1[1]) + (-p0[1] + p2[1]) * t1 + (2 * p0[1] - 5 * p1[1] + 4 * p2[1] - p3[1]) * t2 + (-p0[1] + 3 * p1[1] - 3 * p2[1] + p3[1]) * t3)
            ]);
        }
    }
    smoothed.push(points[points.length - 1]);
    return smoothed;
}

function selectKeyPoints(track) {
    const keyPoints = [];
    let lastCat = null, lastTime = null;
    track.forEach((p, i) => {
        const cat = getCategory(p.vmax_kt || 0);
        const time = new Date(p.time);
        if (i === 0 || i === track.length - 1 || cat !== lastCat || (lastTime && (time - lastTime) / 3600000 >= 6)) {
            keyPoints.push({...p, isLatest: i === track.length - 1});
            lastCat = cat;
            lastTime = time;
        }
    });
    return keyPoints;
}

function plotTrack(track) {
    const scale = BASIN_SCALES[currentBasin];
    
    // Create line segments colored by category
    const trackSegments = [];
    for (let i = 0; i < track.length - 1; i++) {
        const cat = getCategory(track[i].vmax_kt || 0);
        const color = scale.categories[cat].color;
        
        trackSegments.push({
            type: 'Feature',
            geometry: {
                type: 'LineString',
                coordinates: [
                    [track[i].longitude, track[i].latitude],
                    [track[i + 1].longitude, track[i + 1].latitude]
                ]
            },
            properties: {
                category: cat,
                color: color,
                vmax: track[i].vmax_kt || 0
            }
        });
    }
    
    // Add track segments as individual features so they can be colored differently
    map.addSource('storm-track-segments', {
        type: 'geojson',
        data: {
            type: 'FeatureCollection',
            features: trackSegments
        }
    });
    
    // Add glow layer for track segments
    map.addLayer({
        id: 'storm-track-glow',
        type: 'line',
        source: 'storm-track-segments',
        paint: {
            'line-color': ['get', 'color'],
            'line-width': 8,
            'line-blur': 4,
            'line-opacity': 0.4
        }
    });
    
    // Add main track line layer with category colors
    map.addLayer({
        id: 'storm-track-line',
        type: 'line',
        source: 'storm-track-segments',
        paint: {
            'line-color': ['get', 'color'],
            'line-width': 3
        }
    });
    
    const keyPoints = selectKeyPoints(track).filter(p => !p.isLatest);
    map.addSource('storm-points', { 
        type: 'geojson', 
        data: { 
            type: 'FeatureCollection', 
            features: keyPoints.map(p => ({ 
                type: 'Feature', 
                geometry: { type: 'Point', coordinates: [p.longitude, p.latitude]}, 
                properties: { 
                    category: getCategory(p.vmax_kt || 0),
                    time: p.time,
                    vmax: p.vmax_kt || 0,
                    mslp: p.mslp_hpa || 0
                }
            }))
        }
    });
    
    map.addLayer({ 
        id: 'storm-points-layer', 
        type: 'circle', 
        source: 'storm-points', 
        paint: { 
            'circle-radius': 6, 
            'circle-color': ['match', ['get', 'category'], 0, scale.categories[0].color, 1, scale.categories[1].color, 2, scale.categories[2].color, 3, scale.categories[3].color, 4, scale.categories[4].color, 5, scale.categories[5].color, '#5ebaff'], 
            'circle-stroke-width': 2, 
            'circle-stroke-color': '#fff'
        }
    });
    
    // ADD CLICK POPUP
    map.on('click', 'storm-points-layer', (e) => {
        const props = e.features[0].properties;
        const date = new Date(props.time);
        
        new maplibregl.Popup()
            .setLngLat(e.features[0].geometry.coordinates)
            .setHTML(`
                <div style="padding: 0.75rem; min-width: 220px; font-family: system-ui;">
                    <strong style="font-size: 1.1rem; color: #1e40af;">${date.toUTCString()}</strong><br><br>
                    <div style="display: grid; grid-template-columns: auto 1fr; gap: 0.5rem 1rem;">
                        <strong>Winds:</strong> <span>${props.vmax} kt</span>
                        <strong>Pressure:</strong> <span>${props.mslp} mb</span>
                        <strong>Category:</strong> <span>${getCategoryName(props.vmax)}</span>
                    </div>
                </div>
            `)
            .addTo(map);
    });
    
    // CHANGE CURSOR ON HOVER
    map.on('mouseenter', 'storm-points-layer', () => {
        map.getCanvas().style.cursor = 'pointer';
    });
    
    map.on('mouseleave', 'storm-points-layer', () => {
        map.getCanvas().style.cursor = '';
    });
    
    // Add cyclone eye only if latest position is Category 1+
    addCycloneEye(track[track.length - 1]);
}

function addCycloneEye(point) {
    const vmax = point.vmax_kt || 0;
    const cat = getCategory(vmax);
    
    // CRITICAL: Only show tc-eye.png for Category 1+ (cyclone strength)
    // For SH/IO basins: Category 1+ means >= 48kt (thresholds[1])
    // For AL/EP/WP basins: Category 1+ means >= 64kt (thresholds[1])
    const scale = BASIN_SCALES[currentBasin];
    const isCycloneStrength = vmax >= scale.thresholds[1];
    
    if (!isCycloneStrength) {
        // Below cyclone strength - no tc-eye.png
        return;
    }
    
    const text = getCategoryText(vmax);
    const color = scale.textColors[cat];
    const el = document.createElement('div');
    el.style.cssText = 'width: 80px; height: 80px; cursor: pointer;';
    
    // Create rotating or static tc-eye based on whether it's the latest position
    // The rotating animation should ONLY be on the latest plot if it's cyclone strength
    const rotationStyle = 'animation: rotate 6s linear infinite;';
    
    el.innerHTML = `
        <div style="position: relative; width: 80px; height: 80px;">
            <img src="/static/img/tc-eye.png" style="width: 80px; height: 80px; ${rotationStyle}">
            <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-weight: bold; font-size: 18px; color: ${color}; text-shadow: 0 0 3px white, 0 0 3px white;">
                ${text}
            </div>
        </div>
    `;
    
    if (!document.getElementById('cyclone-eye-animation')) {
        const style = document.createElement('style');
        style.id = 'cyclone-eye-animation';
        style.innerHTML = '@keyframes rotate { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }';
        document.head.appendChild(style);
    }
    
    // ADD CLICK POPUP FOR EYE
    el.addEventListener('click', () => {
        const date = new Date(point.time);
        new maplibregl.Popup()
            .setLngLat([point.longitude, point.latitude])
            .setHTML(`
                <div style="padding: 1rem; min-width: 240px; font-family: system-ui;">
                    <strong style="font-size: 1.2rem; color: #1e40af;">CURRENT POSITION</strong><br>
                    <em style="color: #64748b;">${date.toUTCString()}</em><br><br>
                    <div style="display: grid; grid-template-columns: auto 1fr; gap: 0.5rem 1rem;">
                        <strong>Winds:</strong> <span>${point.vmax_kt} kt</span>
                        <strong>Pressure:</strong> <span>${point.mslp_hpa} mb</span>
                        <strong>Category:</strong> <span>${getCategoryName(point.vmax_kt)}</span>
                        <strong>Position:</strong> <span>${point.latitude.toFixed(2)}°, ${point.longitude.toFixed(2)}°</span>
                    </div>
                </div>
            `)
            .addTo(map);
    });
    
    eyeMarker = new maplibregl.Marker({element: el, anchor: 'center'}).setLngLat([point.longitude, point.latitude]).addTo(map);
}

function fitMapToTrack(track) {
    const bounds = new maplibregl.LngLatBounds();
    track.forEach(p => bounds.extend([p.longitude, p.latitude]));
    map.fitBounds(bounds, { padding: 100, maxZoom: 8, duration: 1000 });
}

document.addEventListener('DOMContentLoaded', () => {
    const id = document.querySelector('[data-storm-id]')?.dataset.stormId;
    if (id) initStormMap(id);
});
